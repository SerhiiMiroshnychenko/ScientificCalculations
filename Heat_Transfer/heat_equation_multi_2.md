# Двовимірне рівняння теплопровідності

## Постановка задачі
Даний скрипт розв'язує двовимірне рівняння теплопровідності:

$$ \frac{\partial}{\partial t} u(\vec{r},t) = a \left(\frac{\partial^2}{\partial x^2} u(\vec{r},t) + \frac{\partial^2}{\partial y^2} u(\vec{r},t)\right) $$

де:
- $u(x,y,t)$ - температура в точці $(x,y)$ в момент часу $t$
- $a$ - коефіцієнт температуропровідності
- $t$ - час
- $x, y$ - просторові координати

## Метод розв'язання
1. Використовуємо метод кінцевих різниць для дискретизації просторових похідних
2. Застосовуємо перетворення двовимірного масиву в одновимірний для використання стандартних методів розв'язку
3. Для розв'язку системи використовуємо метод Рунге-Кутти 4-5 порядку
4. Візуалізуємо результати за допомогою контурних графіків

## Теоретичні основи

Двовимірне рівняння теплопровідності описує поширення тепла по площині:

$$ \frac{\partial}{\partial t} u(\vec{r},t) = a \left(\frac{\partial^2}{\partial x^2} u(\vec{r},t) + \frac{\partial^2}{\partial y^2} u(\vec{r},t)\right) $$

де $u(\vec{r},t)$ - температура в точці з координатами $(x,y)$ в момент часу $t$, представлена як двовимірний масив ${u_{1,1}, u_{1,2}, \dots, u_{n,n}}$.

### Дискретизація

Для чисельного розв'язку використовуємо метод кінцевих різниць. Просторові похідні апроксимуються як:

$$ \frac{\partial^2}{\partial x^2} u_{i,j} + \frac{\partial^2}{\partial y^2} u_{i,j} = \frac{u_{i+1,j}-2u_{i,j}+u_{i-1,j}}{(\Delta x)^2}+\frac{u_{i,j+1}-2u_{i,j}+u_{i,j-1}}{(\Delta y)^2} $$

## Реалізація

### Імпорт необхідних бібліотек

```python
import numpy as np          # для роботи з масивами та математичними операціями
import matplotlib.pyplot as plt  # для візуалізації результатів
from scipy import integrate     # для чисельного інтегрування
```

### Визначення параметрів системи

```python
# Визначаємо основні фізичні параметри системи
a = 1.0   # Коефіцієнт температуропровідності
dx = 1.0  # Крок сітки по x
dy = 1.0  # Крок сітки по y

# Визначаємо розміри розрахункової сітки
sizex = 100  # Кількість точок по x
sizey = 100  # Кількість точок по y
```

### Функції для розрахунку правої частини рівняння

```python
def f_2D(t, u):
    """
    Функція, що реалізує праву частину двовимірного рівняння теплопровідності.
    
    Параметри:
    t (float) - поточний час (не використовується, але потрібен для сумісності з solve_ivp)
    u (numpy.array) - двовимірний масив температур розміром [sizex, sizey]
    
    Повертає:
    numpy.array - масив похідних температур по часу для кожної точки
    """
    # Створюємо масив для збереження похідних
    unew = np.zeros([len(u), len(u)])
    
    # Розраховуємо похідні для всіх внутрішніх точок
    # Перший доданок - похідна по x, другий - по y
    unew[1:-1,1:-1] = (u[2:,1:-1] - 2*u[1:-1,1:-1] + u[:-2,1:-1]) * a/dx**2 + \
                      (u[1:-1,2:] - 2*u[1:-1,1:-1] + u[1:-1,:-2]) * a/dy**2
    return unew

def f_2D_flattened(t, u):
    """
    Допоміжна функція для перетворення двовимірної задачі в одновимірну.
    Це необхідно для використання стандартних методів розв'язку ОДУ.
    
    Параметри:
    t (float) - поточний час
    u (numpy.array) - одновимірний масив (розгорнутий двовимірний)
    
    Повертає:
    numpy.array - одновимірний масив похідних
    """
    # Перетворюємо одновимірний масив назад у двовимірний
    u = u.reshape(sizex, sizey)
    
    # Створюємо масив для похідних
    unew = np.zeros([sizex, sizey])
    
    # Розраховуємо похідні для всіх внутрішніх точок
    unew[1:-1,1:-1] = (u[2:,1:-1] - 2*u[1:-1,1:-1] + u[:-2,1:-1]) * a/dx**2 + \
                      (u[1:-1,2:] - 2*u[1:-1,1:-1] + u[1:-1,:-2]) * a/dy**2
    
    # Повертаємо розгорнутий одновимірний масив
    return unew.flatten()
```

### Розв'язання рівняння для першого випадку

```python
# Задаємо параметри часової еволюції
tStart = 0       # Початковий час
tEnd = 10000     # Кінцевий час

# Створюємо початкові умови: нагріті ліва та нижня границі
u0 = np.zeros([sizex, sizey])  # Спочатку температура скрізь нульова
u0[0,:] = 1   # Температура = 1 на лівій границі
u0[:,0] = 1   # Температура = 1 на нижній границі

# Розв'язуємо систему рівнянь
solution = integrate.solve_ivp(
    f_2D_flattened,                          # Функція правої частини
    [tStart, tEnd],                          # Часовий інтервал
    u0.flatten(),                            # Початкові умови (розгорнуті в 1D)
    method='RK45',                           # Метод Рунге-Кутти 4-5 порядку
    t_eval=np.linspace(tStart,tEnd,10001)    # Точки часу для збереження результату
)
```

### Візуалізація результатів

```python
# Створюємо сітку для візуалізації
x_list, y_list = np.meshgrid(np.arange(sizex), np.arange(sizey))

# Початковий момент часу
tIndex = 0
plt.figure(figsize=(10, 8))
plt.xlabel('Координата x')
plt.ylabel('Координата y')
plt.title(f'Розподіл температури в початковий момент часу (t = {solution.t[tIndex]:.1f})')
plt.contourf(x_list, y_list, solution.y[:,tIndex].reshape(sizex, sizey))
plt.colorbar(label='Температура')
plt.show()

# Проміжний момент часу
tIndex = tEnd//200
plt.figure(figsize=(10, 8))
plt.xlabel('Координата x')
plt.ylabel('Координата y')
plt.title(f'Розподіл температури в проміжний момент часу (t = {solution.t[tIndex]:.1f})')
plt.contourf(x_list, y_list, solution.y[:,tIndex].reshape(sizex, sizey))
plt.colorbar(label='Температура')
plt.show()

# Кінцевий момент часу
tIndex = -1
plt.figure(figsize=(10, 8))
plt.xlabel('Координата x')
plt.ylabel('Координата y')
plt.title(f'Розподіл температури в кінцевий момент часу (t = {solution.t[tIndex]:.1f})')
plt.contourf(x_list, y_list, solution.y[:,tIndex].reshape(sizex, sizey))
plt.colorbar(label='Температура')
plt.show()
```

### Розв'язання рівняння для другого випадку

```python
# Створюємо нові початкові умови: нагріті всі границі
u0 = np.zeros([sizex,sizey])  # Спочатку температура скрізь нульова
u0[0,:] = 1    # Температура = 1 на лівій границі
u0[:,0] = 1    # Температура = 1 на нижній границі
u0[-1,:] = 1   # Температура = 1 на правій границі
u0[:,-1] = 1   # Температура = 1 на верхній границі

# Розв'язуємо систему рівнянь з новими умовами
solution = integrate.solve_ivp(
    f_2D_flattened,
    [tStart, tEnd],
    u0.flatten(),
    method='RK45',
    t_eval=np.linspace(tStart,tEnd,10001)
)
```

### Візуалізація результатів для другого випадку

```python
# Початковий момент часу
tIndex = 0
plt.figure(figsize=(10, 8))
plt.xlabel('Координата x')
plt.ylabel('Координата y')
plt.title(f'Розподіл температури в початковий момент часу (t = {solution.t[tIndex]:.1f})')
plt.contourf(x_list, y_list, solution.y[:,tIndex].reshape(sizex, sizey))
plt.colorbar(label='Температура')
plt.show()

# Проміжний момент часу
tIndex = tEnd//200
plt.figure(figsize=(10, 8))
plt.xlabel('Координата x')
plt.ylabel('Координата y')
plt.title(f'Розподіл температури в проміжний момент часу (t = {solution.t[tIndex]:.1f})')
plt.contourf(x_list, y_list, solution.y[:,tIndex].reshape(sizex, sizey))
plt.colorbar(label='Температура')
plt.show()

# Кінцевий момент часу
tIndex = -1
plt.figure(figsize=(10, 8))
plt.xlabel('Координата x')
plt.ylabel('Координата y')
plt.title(f'Розподіл температури в кінцевий момент часу (t = {solution.t[tIndex]:.1f})')
plt.contourf(x_list, y_list, solution.y[:,tIndex].reshape(sizex, sizey))
plt.colorbar(label='Температура')
plt.show()
