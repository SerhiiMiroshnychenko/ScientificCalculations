"""
# Двовимірне рівняння теплопровідності

## Постановка задачі
Даний скрипт розв'язує двовимірне рівняння теплопровідності:
∂u/∂t = a * (∂²u/∂x² + ∂²u/∂y²)

де:
- u(x,y,t) - температура в точці (x,y) в момент часу t
- a - коефіцієнт температуропровідності
- t - час
- x, y - просторові координати

## Метод розв'язання
1. Використовуємо метод кінцевих різниць для дискретизації просторових похідних
2. Застосовуємо перетворення двовимірного масиву в одновимірний для використання стандартних методів розв'язку
3. Для розв'язку системи використовуємо метод Рунге-Кутти 4-5 порядку
4. Візуалізуємо результати за допомогою контурних графіків

## Граничні умови
Реалізовано різні варіанти граничних умов:
1. Постійна температура на лівій та нижній границях
2. Постійна температура на всіх границях
"""

# Імпортуємо необхідні бібліотеки
import numpy as np
import matplotlib.pyplot as plt
from scipy import integrate

# Визначаємо основні фізичні параметри системи
a = 1.0   # Коефіцієнт температуропровідності
dx = 1.0  # Крок сітки по x
dy = 1.0  # Крок сітки по y

def f_2D(t, u):
    """
    Функція, що реалізує праву частину двовимірного рівняння теплопровідності.

    Параметри:
    t (float) - поточний час (не використовується, але потрібен для сумісності з solve_ivp)
    u (numpy.array) - двовимірний масив температур розміром [sizex, sizey]

    Повертає:
    numpy.array - масив похідних температури по часу для кожної точки
    """
    # Створюємо масив для збереження похідних
    unew = np.zeros([len(u), len(u)])

    # Розраховуємо похідні для всіх внутрішніх точок
    # Перший доданок - похідна по x, другий - по y
    unew[1:-1,1:-1] = (u[2:,1:-1] - 2*u[1:-1,1:-1] + u[:-2,1:-1]) * a/dx**2 + \
                      (u[1:-1,2:] - 2*u[1:-1,1:-1] + u[1:-1,:-2]) * a/dy**2
    return unew

# Визначаємо розміри розрахункової сітки
sizex = 100  # Кількість точок по x
sizey = 100  # Кількість точок по y

def f_2D_flattened(t, u):
    """
    Допоміжна функція для перетворення двовимірної задачі в одновимірну.
    Це необхідно для використання стандартних методів розв'язку ОДУ.

    Параметри:
    t (float) - поточний час
    u (numpy.array) - одновимірний масив (розгорнутий двовимірний)

    Повертає:
    numpy.array - одновимірний масив похідних
    """
    # Логуємо поточний час
    if int(t) % 1000 == 0:  # Виводимо кожні 1000 одиниць часу
        print(f"Поточний час розрахунку: t = {int(t)} з {tEnd}")
        
    # Перетворюємо одновимірний масив назад у двовимірний
    u = u.reshape(sizex, sizey)

    # Створюємо масив для похідних
    unew = np.zeros([sizex, sizey])

    # Розраховуємо похідні для всіх внутрішніх точок
    unew[1:-1,1:-1] = (u[2:,1:-1] - 2*u[1:-1,1:-1] + u[:-2,1:-1]) * a/dx**2 + \
                      (u[1:-1,2:] - 2*u[1:-1,1:-1] + u[1:-1,:-2]) * a/dy**2

    # Повертаємо розгорнутий одновимірний масив
    return unew.flatten()

# Задаємо параметри часової еволюції
tStart = 0       # Початковий час
tEnd = 10000     # Кінцевий час

# Створюємо початкові умови: нагріті ліва та нижня границі
u0 = np.zeros([sizex, sizey])  # Спочатку температура скрізь нульова
u0[0,:] = 1   # Температура = 1 на лівій границі
u0[:,0] = 1   # Температура = 1 на нижній границі

# Розв'язуємо систему рівнянь
print("\nПочинаємо розрахунок для випадку з нагрітими лівою та нижньою границями...")
solution = integrate.solve_ivp(
    f_2D_flattened,                          # Функція правої частини
    [tStart, tEnd],                          # Часовий інтервал
    u0.flatten(),                            # Початкові умови (розгорнуті в 1D)
    method='RK45',                           # Метод Рунге-Кутти 4-5 порядку
    t_eval=np.linspace(tStart,tEnd,10001)    # Точки часу для збереження результату
)
print("Розрахунок завершено!")

# Створюємо сітку для візуалізації
x_list, y_list = np.meshgrid(np.arange(sizex), np.arange(sizey))

# Візуалізуємо результати для різних моментів часу

# Початковий момент часу
tIndex = 0
plt.figure(figsize=(10, 8))
plt.xlabel('Координата x')
plt.ylabel('Координата y')
plt.title(f'Розподіл температури в початковий момент часу (t = {solution.t[tIndex]:.1f})')
plt.contourf(x_list, y_list, solution.y[:,tIndex].reshape(sizex, sizey))
plt.colorbar(label='Температура')
plt.show()

# Проміжний момент часу
tIndex = tEnd//200
plt.figure(figsize=(10, 8))
plt.xlabel('Координата x')
plt.ylabel('Координата y')
plt.title(f'Розподіл температури в проміжний момент часу (t = {solution.t[tIndex]:.1f})')
plt.contourf(x_list, y_list, solution.y[:,tIndex].reshape(sizex, sizey))
plt.colorbar(label='Температура')
plt.show()

# Кінцевий момент часу
tIndex = -1
plt.figure(figsize=(10, 8))
plt.xlabel('Координата x')
plt.ylabel('Координата y')
plt.title(f'Розподіл температури в кінцевий момент часу (t = {solution.t[tIndex]:.1f})')
plt.contourf(x_list, y_list, solution.y[:,tIndex].reshape(sizex, sizey))
plt.colorbar(label='Температура')
plt.show()

# %% [markdown]
# ### Інші початкові умови
#
# Розглянемо випадок, коли температура підтримується на всіх границях області

# Задаємо ті самі параметри часової еволюції
tStart = 0
tEnd = 10000

# Створюємо нові початкові умови: нагріті всі границі
u0 = np.zeros([sizex,sizey])  # Спочатку температура скрізь нульова
u0[0,:] = 1    # Температура = 1 на лівій границі
u0[:,0] = 1    # Температура = 1 на нижній границі
u0[-1,:] = 1   # Температура = 1 на правій границі
u0[:,-1] = 1   # Температура = 1 на верхній границі

# Розв'язуємо систему рівнянь з новими умовами
print("\nПочинаємо розрахунок для випадку з нагрітими всіма границями...")
solution = integrate.solve_ivp(
    f_2D_flattened,
    [tStart, tEnd],
    u0.flatten(),
    method='RK45',
    t_eval=np.linspace(tStart,tEnd,10001)
)
print("Розрахунок завершено!")

# Візуалізуємо результати для різних моментів часу

# Початковий момент часу
tIndex = 0
plt.figure(figsize=(10, 8))
plt.xlabel('Координата x')
plt.ylabel('Координата y')
plt.title(f'Розподіл температури в початковий момент часу (t = {solution.t[tIndex]:.1f})')
plt.contourf(x_list, y_list, solution.y[:,tIndex].reshape(sizex, sizey))
plt.colorbar(label='Температура')
plt.show()

# Проміжний момент часу
tIndex = tEnd//200
plt.figure(figsize=(10, 8))
plt.xlabel('Координата x')
plt.ylabel('Координата y')
plt.title(f'Розподіл температури в проміжний момент часу (t = {solution.t[tIndex]:.1f})')
plt.contourf(x_list, y_list, solution.y[:,tIndex].reshape(sizex, sizey))
plt.colorbar(label='Температура')
plt.show()

# Кінцевий момент часу
tIndex = -1
plt.figure(figsize=(10, 8))
plt.xlabel('Координата x')
plt.ylabel('Координата y')
plt.title(f'Розподіл температури в кінцевий момент часу (t = {solution.t[tIndex]:.1f})')
plt.contourf(x_list, y_list, solution.y[:,tIndex].reshape(sizex, sizey))
plt.colorbar(label='Температура')
plt.show()
